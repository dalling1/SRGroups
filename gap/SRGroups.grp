#
# SRGroups: Self-replicating groups of regular rooted trees
#
# Library Functions
#

##################################################################################################################

InstallGlobalFunction(GetSRData,function(k,n)
	local dir, fnam, listTemp;
	
	if not (IsInt(k) and k>=2) then
		Error("input argument k=",k," must be an integer greater than or equal to 2");
	elif not (IsInt(n) and n>=1) then
		Error("input argument n=",n," must be an integer greater than or equal to 1");
	elif not SRGroupsAvailable(k,n) then
		Error("These groups are not available (yet)!");
	else
		dir:= DirectoriesPackageLibrary( "SRGroups", "data" );
		fnam:=Filename( dir[1], Concatenation("sr_",String(k),"_",String(n),".grp"));
		Read(fnam);
		listTemp:=EvalString(Concatenation("sr_",String(k),"_",String(n)));
		MakeReadWriteGlobal(Concatenation("sr_",String(k),"_",String(n)));
		UnbindGlobal(Concatenation("sr_",String(k),"_",String(n)));
		return listTemp;
	fi;
end);

##################################################################################################################

InstallGlobalFunction( GetSRMaximums,
function(arg)
	local deg, lev, max, maxAbove, errorString, i;
	
	if arg[1][1]<>0 and arg[2][1]<>0 then
		if Length(arg)>=3 and (arg[3][1]<>0 or arg[5][1]<>0) then
			for deg in arg[1] do
				for lev in arg[2] do
					if SRGroupsAvailable(deg,lev) then
						if IsBound(max) then
							if max<NrSRGroups(deg,lev) then max:=NrSRGroups(deg,lev); fi;
						else
							max:=NrSRGroups(deg,lev);
						fi;
					fi;
				od;
			od;
		else
			max:=false;
		fi;
		
		if Length(arg)>=4 and arg[4][1]<>0 then
			for deg in arg[1] do
				for lev in arg[2] do
					if SRGroupsAvailable(deg,lev) and SRGroupsAvailable(deg,lev-1) then
						if IsBound(maxAbove) then
							if maxAbove<NrSRGroups(deg,lev-1) then maxAbove:=NrSRGroups(deg,lev-1); fi;
						else
							maxAbove:=NrSRGroups(deg,lev-1);
						fi;
					fi;
				od;
			od;
			if not IsBound(maxAbove) then
				Error("no data available containing two consecutive levels of degree ",String(arg[1])," and level ",String(arg[2])," groups");
			fi;
		else
			maxAbove:=false;
		fi;
	elif arg[1][1]<>0 and arg[2][1]=0 then
		if Length(arg)>=3 and (arg[3][1]<>0 or arg[5][1]<>0) then
			for deg in arg[1] do
				if IsBound(max) then
					if max<NrSRGroups(deg,Maximum(SRLevels(deg))) then max:=NrSRGroups(deg,Maximum(SRLevels(deg))); fi;
				else
					max:=NrSRGroups(deg,Maximum(SRLevels(deg)));
				fi;
			od;
		else
			max:=false;
		fi;
		
		if Length(arg)>=4 and arg[4][1]<>0 then
			for deg in arg[1] do
				if Length(SRLevels(deg))>=2 then
					for i in [2..Length(SRLevels(deg))] do
						if SRLevels(deg)[i]-1=SRLevels(deg)[i-1] then
							if IsBound(maxAbove) then
								if maxAbove<NrSRGroups(deg,SRLevels(deg)[i-1]) then maxAbove:=NrSRGroups(deg,SRLevels(deg)[i-1]); fi;
							else
								maxAbove:=NrSRGroups(deg,SRLevels(deg)[i-1]);
							fi;
						fi;
					od;
				fi;
			od;
			if not IsBound(maxAbove) then
				Error("no data available containing two consecutive levels of degree ",String(arg[1]));
			fi;
		else
			maxAbove:=false;
		fi;
	elif arg[1][1]=0 and arg[2][1]<>0 then
		if Length(arg)>=3 and (arg[3][1]<>0 or arg[5][1]<>0) then
			for deg in SRDegrees() do
				for lev in arg[2] do
					if lev in SRLevels(deg) then
						if IsBound(max) then
							if max<NrSRGroups(deg,lev) then max:=NrSRGroups(deg,lev); fi;
						else
							max:=NrSRGroups(deg,lev);
						fi;
					fi;
				od;
			od;
		else
			max:=false;
		fi;
		
		if Length(arg)>=4 and arg[4][1]<>0 then
			for deg in SRDegrees() do
				for lev in arg[2] do
					if lev in SRLevels(deg) and lev-1 in SRLevels(deg) then
						if IsBound(maxAbove) then
							if maxAbove<NrSRGroups(deg,lev-1) then maxAbove:=NrSRGroups(deg,lev-1); fi;
						else
							maxAbove:=NrSRGroups(deg,lev-1);
						fi;
					fi;
				od;
			od;
			if not IsBound(maxAbove) then
				Error("no data available containing level ",String(arg[1])," and level ",String(arg[1]-1)," groups");
			fi;
		else
			maxAbove:=false;
		fi;
	else
		if Length(arg)>=3 and (arg[3][1]<>0 or arg[5][1]<>0) then
			max:=1;
			for deg in SRDegrees() do
				for lev in SRLevels(deg) do
					if NrSRGroups(deg,lev)>max then
						max:=NrSRGroups(deg,lev);
					fi;
				od;
			od;
		else
			max:=false;
		fi;
		
		if Length(arg)>=4 and arg[4][1]<>0 then
			maxAbove:=0;
			for deg in SRDegrees() do
				if Length(SRLevels(deg))>=2 then
					for i in [2..Length(SRLevels(deg))] do
						if SRLevels(deg)[i]-1=SRLevels(deg)[i-1] then
							if NrSRGroups(deg,SRLevels(deg)[i-1])>maxAbove then
								maxAbove:=NrSRGroups(deg,SRLevels(deg)[i-1]);
							fi;
						fi;
					od;
				fi;
			od;
			if maxAbove=0 then
				Error("no data available containing two consecutive levels");
			fi;
		else
			maxAbove:=false;
		fi;
	fi;
	
	return [max,maxAbove];
end);

##################################################################################################################

InstallGlobalFunction( CheckSRGroupsInputs,
function(arg)
	local deg, lev, newDegs, newLevs, cont, errorString, i, j, k, argMinimums, argFunctions, degs, levs, max;
	
	if arg[1]=true then
		argMinimums:=arg[2];
		argFunctions:=arg[3];
		degs:=arg[4];
		levs:=arg[5];
		for deg in degs do
			if deg<>0 then
				if not (IsInt(deg) and (deg>=argMinimums[1] or deg=0)) then
					Error("input argument ",argFunctions[1],"=",deg," in arg[1] must be an integer greater than or equal to ", argMinimums[1]," or zero");
				fi;
			fi;
		od;
		
		for lev in levs do
			if lev<>0 then
				if not (IsInt(lev) and (lev>=argMinimums[2] or lev=0)) then
					if argMinimums[2]=2 then
						Error("input argument ",argFunctions[2],"=",lev," in arg[2] must be an integer greater than or equal to ", argMinimums[2]," or zero when the ",argFunctions[5]," argument is being used");
					else
						Error("input argument ",argFunctions[2],"=",lev," in arg[2] must be an integer greater than or equal to ", argMinimums[2]," or zero");
					fi;
				fi;
			fi;
		od;
		
		cont:=false;
		newDegs:=[];
		newLevs:=[];
		for deg in degs do
			for lev in levs do
				if deg<>0 and lev<>0 then
					if IsBound(argMinimums[6]) then
						if deg^lev<argMinimums[6] then argMinimums[6]:=deg^lev; fi;
					else
						argMinimums[6]:=deg^lev;
					fi;
					if SRGroupsAvailable(deg,lev) then
						cont:=true;
						if not deg in newDegs then Add(newDegs,deg); fi;
						if not lev in newLevs then Add(newLevs,lev); fi;
					fi;
				elif deg<>0 and lev=0 then
					if IsBound(argMinimums[6]) then
						if deg<argMinimums[6] then argMinimums[6]:=deg; fi;
					else
						argMinimums[6]:=deg;
					fi;
					if deg in SRDegrees() then
						Add(newDegs,deg);
						cont:=true;
					fi;
				elif deg=0 and lev<>0 then
					if not IsBound(argMinimums[6]) then argMinimums[6]:=2; fi;
					for i in [1..Length(SRDegrees())] do
						if lev in SRLevels(SRDegrees()[i]) then
							Add(newLevs,lev);
							cont:=true;
							break;
						fi;
					od;
				else
					cont:=true;
					argMinimums[6]:=2;
				fi;
			od;
		od;
		
		if cont then
			StableSort(newDegs);
			StableSort(newLevs);
			return [cont,argMinimums,newDegs,newLevs];
		else
			if degs[1]<>0 and levs[1]<>0 then
				Error("no data containing degree ",String(degs)," and level ",String(levs)," is available");
			elif degs[1]<>0 and levs[1]=0 then
				Error("no data containing degree ",String(degs)," is available");
			elif degs[1]=0 and levs[1]<>0 then
				Error("no data containing level ",String(levs)," is available");
			fi;
		fi;
	else
		i:=arg[1];
		argMinimums:=arg[3];
		argFunctions:=arg[4];
		degs:=arg[5];
		levs:=arg[6];
		if i in [3,4,5] then
			max:=arg[7];
		fi;
		arg:=arg[2];
		
		if i<9 then
			if arg<>0 then
				if i in [3,4,5,8] or not arg>=argMinimums[i] then
					if i in [3,5] then
						if arg>=argMinimums[i] and arg<=max then
							return true;
						else
							errorString:=Concatenation("input argument ",String(argFunctions[i]),"=",String(arg)," in arg[",String(i),"] must be an integer in [",String(argMinimums[i]),"..",String(max),"] or zero");
						fi;
					elif i=4 then
						if arg>=argMinimums[i] and arg<=max then
							return true;
						else
							errorString:=Concatenation("input argument ",String(argFunctions[i]),"=",String(arg)," in arg[",String(i),"] must be an integer in [",String(argMinimums[i]),"..",String(max),"] or zero");
						fi;
					elif i=8 then
						if arg>=argMinimums[i] and arg<=4 then
							return true;
						else
							errorString:=Concatenation("input argument ",String(argFunctions[i]),"=",String(arg)," in arg[",String(i),"] must be an integer in [1..4] or zero");
						fi;
					else
						errorString:=Concatenation("input argument ",String(argFunctions[i]),"=",String(arg)," in arg[",String(i),"] must be an integer greater than or equal to ",String(argMinimums[i])," or zero");
					fi;
				else
					return true;
				fi;
			else
				return true;
			fi;
		else 
			if not (IsBool(arg) or arg=0) then
				errorString:=Concatenation("input argument ",String(argFunctions[i]),"=",String(arg)," in arg[",String(i),"] must be a boolean or zero");
			else
				return true;
			fi;
		fi;
		
		return errorString;
	fi;
end);

##################################################################################################################

InstallGlobalFunction( StringVariables, function(arg)
	local Superstring, i;

	for i in [1..Length(arg)] do
		if i=1 then
			Superstring:=Concatenation("varArg",String(i),":=",String(arg[i]),";");
		else
			Superstring:=Concatenation(Superstring,"\nvarArg",String(i),":=",String(arg[i]),";");
		fi;
	od;

	return Superstring;
end);

##################################################################################################################

InstallGlobalFunction( UnbindVariables,
function(arg)
	local k;

	for k in [1..Length(arg)] do
		UnbindGlobal(arg[k]);
	od;
	
	return;
end);

##################################################################################################################




